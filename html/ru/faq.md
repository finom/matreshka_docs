## [FAQ](#!faq)

### Как работает Seemple.js?

Seemple.js использует акцессоры (accessors) для реализации двустороннего связывания данных и отлова событий изменения свойств.

В качестве примера того, как работает двустороннее связывание (в частности, функция {@link Seemple.bindNode}), взгляните на этот код:
```js
function bindNode(object, key, node, binder) {
    const value = object[key];
    Object.defineProperty(object, key, {
        get() {
            return value;
        },
        set(v) {
            binder.setValue.call(node, v);
        }
    });

    node.addEventListener(binder.on, () => {
        value = binder.getValue.call(node);
    });
};
```
Для упрощения, функция не поддерживает связь многие-ко-многим и другие фичи оригинала.


### Есть ли во фреймворке роутинг?
Да, [seemple-router](https://github.com/finom/seemple-router) реализует двустороннее связывание свойства и части URL в стиле Seemple.js. Подробное описание на русском можно прочесть [в статье на Хабре](https://habrahabr.ru/company/seemple/blog/277171/).

### Как предварительно отрендерить приложение на сервере?

Можно использовать Seemple.js на сервере Node.js (требуется наличие [jsdom](https://github.com/tmpvar/jsdom), точнее, объекта ``window``, доступного глобально) либо воспользоваться совершенно любым шаблонизатором на любой серверной платформе. Первый вариант подходит для статичной генерации HTML, второй - для страниц, которые генерируются при каждом обращении пользователя.

Задача клиентской стороны - восстановить приложение из HTML. {@link Seemple#bindNode} извлечет состояние элемента и присвоит его свойству, а {@link Seemple.Array#restore} восстановит состояние коллекции.


### Что такое debounce?

В документации часто встречается фраза "микропаттерн debounce". Это распространенный паттерн, который превращает несколько вызовов функции в течение определенного времени в один вызов. Подробнее в [статье на Хабрахабр](https://habrahabr.ru/post/60957/) или [на англоязычном ресурсе](https://davidwalsh.name/javascript-debounce-function).

### Что из себя должно представлять крупное приложение?

Приложение на базе Seemple.js, как правило, представляет из себя один вложенный JavaScript объект, каждая ветвь которого - экземпляр {@link Seemple}. Новые ветви приложения создаются при помощи {@link Seemple#instantiate}, что гарантирует целостность приложения и возможность вернуть предыдущее состояние приложения или одной его ветви обычными присваиванием.


### Как отрендерить один объект в контейнерах нескольких коллекций?

Первое: нужно установить классу этого объекта свойство ``bindRenderedAsSandbox`` со значением ``false``. Это отключает автоматическое создание песочницы при рендеринге объекта в массиве (т. к. запрещено одному объекту иметь две песочницы).

Второе: по событию ``render`` проверить, в какой массив был вставлен объект и объявить байндинги, соответствующие массиву. Родительский массив и отрисованный элемент можно получить, обратившись к свойствам ``parentArray`` и ``node`` объекта события.

Пример. Есть класс объекта ``User`` и две коллекции: ``UsersA`` и ``UsersB`` (их {@link Seemple.Array#itemRenderer} может отличаться). Для обоих коллекций ``User`` используется в качестве {@link Seemple.Array#Model}.

```js
class User extends Seemple.Object {
	constructor() {
		super();

		this.bindRenderedAsSandbox = false;

		setInterval(() => {
			// изменив name изменятся и все связанные
			// с этим свойством элементы
			this.name = Math.random();
		}, 5000);
	}
	onRender(evt) {
		const { parentArray, node } = evt;

		if(parentArray instanceof UsersA) {
			this.bindNode({
				// создаём псевдо-песочницу
				// для синтаксического сахара в селекторах
				// (это не обязательно)
				nodeA: node,
				name: ':bound(nodeA) .name',
				email: ':bound(nodeA) .email',
			});
		} else if(parentArray instanceof UsersB) {
			this.bindNode({
				nodeB: node,
				name: ':bound(nodeB) .user-name',
			});
		}
	}
}
```

На самом деле есть много способов решения этой задачи. Например, можно объявлять байндинги на уровне массива (т. е. массив будет слушать событие ``render`` вставленных объектов) или на уровне массива привязывать только псевдо-песоницу, а на уровне объекта слушать событие ``bind`` и объявлять остальные привязки...
