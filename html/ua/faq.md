## [FAQ](#!faq)

### Як працює Seemple.js?

Фреймворк використовує акцессори (accessors) для реалізації двостороннього зв'язування даних і вилову подій зміни властивостей.

Для того щоб зрозуміти, як працює двостороннє зв'язування (зокрема, функція {@link Seemple.bindNode}), погляньте на цей код:
```js
function bindNode(object, key, node, binder) {
    const value = object[key];
    Object.defineProperty(object, key, {
        get() {
            return value;
        },
        set(v) {
            binder.setValue.call(node, v);
        }
    });

    node.addEventListener(binder.on, () => {
        value = binder.getValue.call(node);
    });
};
```
Для спрощення, функція не підтримує зв'язок багато-до-багатьох і інші фічі оригіналу.


### Як попередньо відрендерити додаток на сервері?

Можна використовувати Seemple.js на сервері Node.js (потрібна наявність [jsdom](https://github.com/tmpvar/jsdom), точніше, об'єкта ``window``, доступного глобально) або скористатися абсолютно будь-яким шаблонізатором на будь-якій серверній платформі. Перший варіант підходить для статичної генерації HTML, другий - для сторінок, які генеруються при кожному зверненні користувача.

Завдання клієнтської сторони - відтворити додаток з HTML. {@link Seemple#bindNode} витягне стан елемента і привласнить його властивості, а {@link Seemple.Array#restore} відновить стан колекції.


### Що таке debounce?

У документації часто зустрічається фраза "мікропаттерн debounce". Це поширений патерн, який перетворює кілька викликів функції протягом певного часу в один виклик. Детальніше [тут](https://davidwalsh.name/javascript-debounce-function).


### Що з себе повинен представляти великий додаток?

Додаток на базі Seemple.js, як правило, представляє з себе один вкладений JavaScript об'єкт, кожна гілка якого - екземпляр {@link Seemple}. Нові гілки додатку створюються за допомогою {@link Seemple#instantiate}, що гарантує цілісність програми та можливість повернути попередній стан додатку або однієї його гілки звичайними привласненням.


### Як відрендерити один об'єкт в контейнерах декількох колекцій?

Перше: потрібно встановити класу цього об'єкту властивість ``bindRenderedAsSandbox`` зі значенням ``false``. Це відключає автоматичне створення пісочниці при рендеринзі об'єкта в масиві (так як заборонено одному об'єкту мати дві пісочниці).

Друге: за подією ``render`` перевірити, в якій масив був вставлений об'єкт і оголосити байндінги, відповідні до масиву. Батьківський масив і відмальований елемент можна отримати, звернувшись до властивостей ``parentArray`` і ``node`` об'єкта події.

Приклад. Є клас об'єкта ``User`` і дві колекції: ``UsersA`` і ``UsersB`` (їх {@link Seemple.Array#itemRenderer} може відрізнятися). Для обох колекцій ``User`` використовується в якості {@link Seemple.Array#Model}.

```js
class User extends Seemple.Object {
	constructor() {
		super();

		this.bindRenderedAsSandbox = false;

		setInterval(() => {
			// змінивши name зміняться і всі пов'язані
			// з цією властивістю елементи
			this.name = Math.random();
		}, 5000);
	}
	onRender(evt) {
		const { parentArray, node } = evt;

		if(parentArray instanceof UsersA) {
			this.bindNode({
				// створюємо псевдо-пісочницю
				// для синтаксичного цукру в селекторах
				// (це не обов'язково)
				nodeA: node,
				name: ':bound(nodeA) .name',
				email: ':bound(nodeA) .email',
			});
		} else if(parentArray instanceof UsersB) {
			this.bindNode({
				nodeB: node,
				name: ':bound(nodeB) .user-name',
			});
		}
	}
}
```

Насправді є багато способів вирішення цієї задачі. Наприклад, можна оголошувати байндінги на рівні масиву (тобто масив буде слухати подію ``render`` вставлених об'єктів) або на рівні масиву прив'язувати тільки псевдо-песоніцу, а на рівні об'єкта слухати подію ``bind`` і оголошувати інші прив'язки...
